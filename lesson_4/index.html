<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="UTF-8">
	<title>JavaScript ДЗ. Урок 3.</title>
		<meta http-equiv="Content-type" content="text/html; charset=utf-8" />
		<link href="style.css" rel="stylesheet" type="text/css" />
		<script type="text/javascript" src="jquery-2.2.0.min.js"></script>
		<script type="text/javascript" src="jtabs.js"></script>
</head>
<body>
	<div id="jtabs">
		<ul>
			<li>Метод bind()</li>
			<li>Метод call()</li>
			<li>Метод apply()</li>
			<li>Свойство function.arguments</li>
		</ul>
		<div>Метод bind() создаёт новую функцию (привязанную функцию) с тем же самым телом функции (внутренним свойством call в терминах ECMAScript 5), что и у функции, для которой он вызывается (целевая функция привязанной функции), со значением this, привязанным к первому аргументу bind(), которое не может быть переопределено. Метод bind() также принимает ведущие аргументы по умолчанию, передаваемые в целевую функцию при вызове привязанной функции. Привязанная функция также может быть сконструирована с помощью оператора new: это работает так, как если бы вместо неё конструировалась целевая функция. Предоставляемое значение this в этом случае игнорируется, хотя ведущие аргументы всё ещё передаются в эмулируемую функцию.</div>
		<div>Вы можете присваивать различные объекты this при вызове существующей функции. this ссылается на текущий объект, вызвавший объект. С помощью call вы можете написать метод один раз, а затем наследовать его в других объектах, без необходимости переписывать метод для каждого нового объекта.</div>
		<div>Вы можете присваивать различные объекты this при вызове существующей функции. this ссылается на текущий объект, вызывающий объект. С помощью apply() вы можете написать метод один раз, а затем наследовать его в других объектах без необходимости переписывать метод для каждого нового объекта.

Метод apply очень похож на метод call(), за исключением поддерживаемого типа аргументов. Вы можете использовать массив аргументов вместо набора именованных параметров. Вместе с apply вы можете использовать литерал массива, например, fun.apply(this, ['есть', 'бананы']), либо объект Array, например, fun.apply(this, new Array('есть', 'бананы')).

Также вы можете использовать в качестве параметра argsArray псевдомассив arguments. arguments является локальной переменной функции. Он может использоваться для всех неопределённых аргументов вызываемого объекта. Таким образом, вы не обязаны знать, сколько и какие аргументы требует вызываемый объект при использовании метода apply(). Вы можете использовать псевдомассив arguments для передачи всех аргументов в вызываемый объект. Вызываемый объект самостоятельно разберётся с обработкой аргументов.

Начиная с 5-го издания ECMAScript, вы также можете использовать любой вид массивоподобного объекта, что на практике означает, что он должен иметь свойство length и целочисленные свойства в диапазоне (0...length). В качестве примера, теперь вы можете использовать NodeList или свой собственный объект вида { 'length': 2, '0': 'есть', '1': 'бананы' }.</div>
		<div>Синтаксис function.arguments устарел. Рекомендуемым способом доступа к объекту arguments, доступному внутри функций, являеся простая ссылка на переменную arguments.

В случае рекурсии, то есть, если функция f несколько раз появляется в стеке вызовов, значение f.arguments представляет аргументы, соответствующие самому последнему вызову функции.</div>
	</div>

</body>
</html>